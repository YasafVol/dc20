This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
package.json
prisma/schema.prisma
projectPlan/mvp.md
projectPlan/stage1.md
projectPlan/stage2.md
projectPlan/tailwind.config.js
src/lib/rulesdata/ancestries.ts
src/lib/rulesdata/attributes.ts
src/lib/rulesdata/classes.ts
src/lib/rulesdata/traits.ts
src/lib/rulesdata/types.ts
src/lib/stores/characterInProgressStore.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "devDependencies": {
    "prisma": "^6.7.0",
    "svelte": "^5.28.2"
  },
  "dependencies": {
    "@prisma/client": "^6.7.0"
  }
}
</file>

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite" // Using SQLite for simplicity in MVP
  url      = env("DATABASE_URL")
}

// Model to store the character creation progress
model CharacterInProgress {
  id                   String @id @default(uuid())
  // Stage A: Attributes
  attribute_might      Int    @default(-2)
  attribute_agility    Int    @default(-2)
  attribute_charisma   Int    @default(-2)
  attribute_intelligence Int  @default(-2)
  pointsSpent          Int    @default(0) // Points spent in point buy

  // Stage B: Ancestry
  ancestry1Id          String? // ID of the first ancestry
  ancestry2Id          String? // ID of the second ancestry (for mixed ancestry)
  selectedTraitIds     String // JSON string of selected trait IDs
  ancestryPointsSpent  Int    @default(0) // Points spent on traits

  // Stage C: Class
  classId              String? // ID of the selected class
  selectedFeatureChoices String // JSON string of selected feature choice IDs/values

  // Stage D: Skills (MVP Scope)
  // Will add skill selection fields here later

  // Stage E: Equipment (MVP Scope)
  // Will add equipment selection fields here later

  // Stage F: Details (MVP Scope)
  finalName            String?
  finalPlayerName      String?

  // Link to the final character sheet data (once creation is complete)
  finalCharacterSheet  CharacterSheetData?

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// Model to store the final calculated character sheet data
model CharacterSheetData {
  id                   String @id @default(uuid())
  characterInProgressId String @unique // Link back to the progress record
  characterInProgress  CharacterInProgress @relation(fields: [characterInProgressId], references: [id])

  // Final Calculated Stats (based on MVP mvp.md Section IV)
  finalName            String
  finalPlayerName      String?
  finalLevel           Int    @default(1)

  finalMight           Int
  finalAgility         Int
  finalCharisma        Int
  finalIntelligence    Int

  finalPrimeModifierValue Int
  finalPrimeModifierAttribute String

  finalCombatMastery   Int    @default(1)

  finalSaveMasteryMight Int
  finalSaveMasterityAgility Int
  finalSaveMasteryCharisma Int
  finalSaveMasteryIntelligence Int

  finalHPMax           Int
  finalSPMax           Int
  finalMPMax           Int

  finalPD              Int
  finalAD              Int

  finalPDR             String?
  finalEDR             String?
  finalMDR             String?

  finalSaveDC          Int
  finalDeathThreshold  Int
  finalMoveSpeed       Int
  finalJumpDistance    Int
  finalRestPoints      Int
  finalGritPoints      Int
  finalInitiativeBonus Int

  skillsJson           String // JSON string of skill data
  tradesJson           String // JSON string of trade data
  languagesJson        String // JSON string of language data

  ancestry1Name        String?
  ancestry2Name        String?
  selectedTraitsJson   String // JSON string of selected traits

  className            String
  classFeaturesLvl1Json String // JSON string of Lvl 1 class features

  equipmentJson        String // JSON string of equipment

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}
</file>

<file path="src/lib/rulesdata/ancestries.ts">
// src/lib/rulesdata/ancestries.ts

import type { IAncestry } from './types';

export const ancestriesData: IAncestry[] = [
  {
    id: 'human',
    name: 'Human',
    description: 'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
    defaultTraitIds: ['human_resolve'], // Example default trait
    expandedTraitIds: [ // Example expanded traits available for selection
      'human_attribute_increase',
      'human_skill_expertise',
      'negative_trait_example', // Include example negative trait
      'minor_trait_example', // Include example minor trait
    ],
  },
  {
    id: 'elf',
    name: 'Elf',
    description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
    defaultTraitIds: ['elf_keen_senses'], // Example default trait
    expandedTraitIds: [ // Example expanded traits available for selection
      'elf_fey_ancestry',
      'elf_long_strider',
      'negative_trait_example', // Include example negative trait
      'minor_trait_example', // Include example minor trait
    ],
  },
  // Add other ancestries as needed
];
</file>

<file path="src/lib/rulesdata/attributes.ts">
// src/lib/rulesdata/attributes.ts

import type { IAttributeData } from './types';

export const attributesData: IAttributeData[] = [
  {
    id: 'might',
    name: 'Might',
    description: 'Your Strength of Body. (DC20 p.9)',
    derivedStats: [
      { statName: 'Precision Defense (PD)', formula: '8 + CM + Might + Intelligence + Equip' },
      { statName: 'Area Defense (AD)', formula: '8 + CM + Might + Charisma + Equip' },
      { statName: 'Jump Distance', formula: 'Agility < 1 ? 1 : Agility' }, // Jump distance is based on Agility, but Might contributes to AD
    ],
  },
  {
    id: 'agility',
    name: 'Agility',
    description: 'Your Balance, Nimbleness, and Dexterity. (DC20 p.9)',
    derivedStats: [
      { statName: 'Precision Defense (PD)', formula: '8 + CM + Might + Intelligence + Equip' },
      { statName: 'Jump Distance', formula: 'Agility < 1 ? 1 : Agility' },
      { statName: 'Initiative Bonus', formula: 'Base + Agility' },
    ],
  },
  {
    id: 'charisma',
    name: 'Charisma',
    description: 'Your Charm, Presence, Persuasiveness, and Force of Will. (DC20 p.9)',
    derivedStats: [
      { statName: 'Area Defense (AD)', formula: '8 + CM + Might + Charisma + Equip' },
      { statName: 'Grit Points', formula: 'Base + Charisma' },
      { statName: 'Save DC', formula: '8 + CM + Prime Modifier Value + Charisma' }, // Assuming Charisma is used for Save DC calculation if not Prime Mod
    ],
  },
  {
    id: 'intelligence',
    name: 'Intelligence',
    description: 'Your Reasoning, Understanding, and Wisdom. (DC20 p.9)',
    derivedStats: [
      { statName: 'Precision Defense (PD)', formula: '8 + CM + Might + Intelligence + Equip' },
      { statName: 'Skill Points', formula: '5 + Intelligence Modifier' },
      { statName: 'Save DC', formula: '8 + CM + Prime Modifier Value + Intelligence' }, // Assuming Intelligence is used for Save DC calculation if not Prime Mod
    ],
  },
];
</file>

<file path="src/lib/rulesdata/classes.ts">
// src/lib/rulesdata/classes.ts

import type { IClassDefinition } from './types';

export const classesData: IClassDefinition[] = [
  {
    id: 'barbarian',
    name: 'Barbarian',
    description: 'A fierce warrior of primitive background who can enter a battle rage.',
    baseHpContribution: 12, // DC20 p.118
    startingSP: 0, // DC20 p.118
    startingMP: 0, // DC20 p.118
    skillPointGrantLvl1: 0, // DC20 p.118
    saveDCBase: 8, // DC20 p.118
    deathThresholdBase: 10, // DC20 p.118
    moveSpeedBase: 30, // DC20 p.118
    restPointsBase: 4, // DC20 p.118
    gritPointsBase: 2, // DC20 p.118 (Base Grit, before Charisma mod)
    initiativeBonusBase: 0, // DC20 p.118 (Base Initiative, before Agility mod)
    level1Features: [
      {
        id: 'barbarian_rage',
        name: 'Rage',
        description: 'In battle, you fight with primal ferocity. On your turn, you can enter a rage as a bonus action.', // DC20 p.118 (Summarized)
        level: 1,
        effects: [], // Effects of Rage are complex, likely handled in character sheet logic
      },
      {
        id: 'barbarian_unarmored_defense',
        name: 'Unarmored Defense',
        description: 'While you are wearing no armor, your Armor Class equals 10 + your Agility modifier + your Might modifier.', // DC20 p.118
        level: 1,
        effects: [], // Effect applied in defense calculation logic
      },
    ],
    featureChoicesLvl1: [], // Barbarian has no Lvl 1 feature choices listed on p.118
  },
  {
    id: 'sorcerer',
    name: 'Sorcerer',
    description: 'A spellcaster who draws on inherent magic from a gift or bloodline.',
    baseHpContribution: 6, // DC20 p.149
    startingSP: 0, // DC20 p.149
    startingMP: 6, // DC20 p.149
    skillPointGrantLvl1: 0, // DC20 p.149
    saveDCBase: 8, // DC20 p.149
    deathThresholdBase: 10, // DC20 p.149
    moveSpeedBase: 30, // DC20 p.149
    restPointsBase: 4, // DC20 p.149
    gritPointsBase: 2, // DC20 p.149 (Base Grit, before Charisma mod)
    initiativeBonusBase: 0, // DC20 p.149 (Base Initiative, before Agility mod)
    level1Features: [
      {
        id: 'sorcerer_spellcasting',
        name: 'Spellcasting',
        description: 'You can cast spells.', // DC20 p.149 (Summarized)
        level: 1,
        effects: [], // Spellcasting is complex, handled elsewhere
      },
      {
        id: 'sorcerer_sorcerous_origin',
        name: 'Sorcerous Origin',
        description: 'Choose a sorcerous origin, which describes the source of your innate magical power.', // DC20 p.149
        level: 1,
        effects: [], // The choice itself grants effects, not this base feature
      },
    ],
    featureChoicesLvl1: [
      {
        id: 'sorcerous_origin_choice',
        prompt: 'Choose your Sorcerous Origin:',
        type: 'select_one',
        options: [
          {
            value: 'draconic_bloodline',
            label: 'Draconic Bloodline',
            description: 'Your innate magic comes from draconic magic that was mingled with your blood or that of your ancestors.', // DC20 p.150 (Summarized)
            effectsOnChoice: [
              { type: 'GRANT_FEATURE', target: 'draconic_bloodline_feature' }, // Placeholder for granting origin features
              { type: 'GRANT_HP_PER_LEVEL', value: 1 }, // Draconic Resilience HP increase
              { type: 'GRANT_UNARMORED_AC', value: { formula: '13 + Agility' } }, // Draconic Resilience AC
            ],
          },
          {
            value: 'intuitive_magic',
            label: 'Intuitive Magic',
            description: 'Your magic comes from a deep, innate understanding of the weave.', // DC20 p.151 (Summarized)
            effectsOnChoice: [
               { type: 'GRANT_FEATURE', target: 'intuitive_magic_feature' }, // Placeholder for granting origin features
               { type: 'MODIFY_STAT', target: 'skillPointGrantLvl1', value: 2 }, // Gain 2 additional skill points
            ],
          },
          // Add other origins as needed
        ],
      },
    ],
  },
  // Add other classes as needed
];
</file>

<file path="src/lib/rulesdata/traits.ts">
// src/lib/rulesdata/traits.ts

import type { ITrait } from './types';

export const traitsData: ITrait[] = [
  // Human Traits
  {
    id: 'human_resolve',
    name: 'Human Resolve',
    description: 'Gain +1 to your Death Threshold.',
    cost: 1,
    effects: [{ type: 'MODIFY_STAT', target: 'deathThresholdBase', value: 1 }],
  },
  {
    id: 'human_attribute_increase',
    name: 'Attribute Increase',
    description: 'Increase one attribute of your choice by 1.',
    cost: 1,
    effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'any_attribute_choice', value: 1, userChoiceRequired: { prompt: "Choose an attribute to increase by 1" } }],
  },
  {
    id: 'human_skill_expertise',
    name: 'Skill Expertise',
    description: 'Gain Expertise in one skill of your choice. Your mastery cap for this skill increases by 1, and your mastery level increases by 1.',
    cost: 1,
    effects: [{ type: 'GRANT_SKILL_EXPERTISE', value: { skillId: 'any_skill_choice', capIncrease: 1, levelIncrease: 1 }, userChoiceRequired: { prompt: "Choose a skill for Expertise" } }],
  },
  // Elf Traits
  {
    id: 'elf_keen_senses',
    name: 'Keen Senses',
    description: 'You have advantage on Perception checks.', // Placeholder effect type
    cost: 1,
    effects: [{ type: 'ADVANTAGE_ON_SKILL', target: 'perception' }],
  },
  {
    id: 'elf_fey_ancestry',
    name: 'Fey Ancestry',
    description: 'You have advantage on saving throws against being charmed, and magic can\'t put you to sleep.', // Placeholder effect type
    cost: 1,
    effects: [
      { type: 'ADVANTAGE_ON_SAVE_TYPE', target: 'charmed' },
      { type: 'IMMUNITY_TO_EFFECT_TYPE', target: 'magical_sleep' },
    ],
  },
  {
    id: 'elf_long_strider',
    name: 'Long Strider',
    description: 'Your base movement speed increases by 5 feet.',
    cost: 1,
    effects: [{ type: 'MODIFY_STAT', target: 'moveSpeedBase', value: 5 }],
  },
  // Example Negative Trait
   {
    id: 'negative_trait_example',
    name: 'Example Negative Trait',
    description: 'This is an example of a negative trait.',
    cost: -1, // Grants 1 point
    isNegative: true,
    effects: [], // Negative traits might not have positive effects
  },
   // Example Minor Trait
   {
    id: 'minor_trait_example',
    name: 'Example Minor Trait',
    description: 'This is an example of a minor trait.',
    cost: 1,
    isMinor: true,
    effects: [], // Minor traits might not have effects, or minor ones
  },
];
</file>

<file path="src/lib/rulesdata/types.ts">
// src/lib/rulesdata/types.ts

// Interface for Attribute Data
export interface IAttributeData {
  id: 'might' | 'agility' | 'charisma' | 'intelligence';
  name: string;
  description: string;
  derivedStats?: Array<{ statName: string; formula: string; }>;
}

// Interface for Trait Effects
export interface ITraitEffect {
  type: string; // e.g., 'MODIFY_ATTRIBUTE', 'GRANT_SKILL_EXPERTISE', 'GRANT_FEATURE'
  target?: string; // e.g., attribute ID ('might'), skill ID ('athletics'), feature ID ('rage')
  value?: any; // e.g., number for attribute modification, object for skill expertise details
  condition?: string; // Optional condition for the effect to apply
  userChoiceRequired?: { // Details if the user needs to make a choice for this effect
    prompt: string; // Prompt shown to the user
    options?: string[]; // Optional list of specific options (e.g., skill IDs, attribute IDs)
  };
  descriptionOverride?: string; // Optional override for how this effect is described
}

// Interface for Traits
export interface ITrait {
  id: string;
  name: string;
  description: string;
  cost: number; // Ancestry points cost
  isMinor?: boolean; // True if this is a Minor Trait
  isNegative?: boolean; // True if this is a Negative Trait (grants points)
  effects?: ITraitEffect[]; // Array of effects the trait grants
  prerequisites?: any[]; // Optional prerequisites for taking this trait
}

// Interface for Ancestries
export interface IAncestry {
  id: string;
  name: string;
  description: string;
  defaultTraitIds?: string[]; // Traits automatically granted
  expandedTraitIds: string[]; // Traits available for selection
}

// Interface for Class Feature Choice Options
export interface IClassFeatureChoiceOption {
  value: string; // Internal value for the choice
  label: string; // Display label for the choice
  description?: string; // Optional description for the choice
  effectsOnChoice?: ITraitEffect[]; // Effects granted if this option is chosen
}

// Interface for Class Feature Choices
export interface IClassFeatureChoice {
  id: string; // Internal ID for the choice (e.g., 'sorcerousOrigin')
  prompt: string; // Prompt shown to the user
  type: 'select_one' | 'select_multiple'; // Type of selection
  maxSelections?: number; // Max number of options if type is 'select_multiple'
  options: IClassFeatureChoiceOption[]; // Available options for the choice
}

// Interface for Class Features
export interface IClassFeature {
  id: string;
  name: string;
  description: string;
  level: number; // Level at which the feature is gained
  effects?: ITraitEffect[]; // Effects granted by the feature
}

// Interface for Class Definitions
export interface IClassDefinition {
  id: string;
  name: string;
  description: string;
  // Base stats granted by the class at Level 1
  baseHpContribution: number;
  startingSP: number;
  startingMP: number;
  skillPointGrantLvl1?: number; // Additional skill points granted at Lvl 1 (beyond Int mod)
  // ... other base stats like Save DC, Death Threshold, Move Speed, Rest Points, Grit Points, Initiative Bonus
  saveDCBase: number;
  deathThresholdBase: number;
  moveSpeedBase: number;
  restPointsBase: number;
  gritPointsBase: number; // Base grit points (before Charisma mod)
  initiativeBonusBase: number; // Base initiative bonus (before Agility mod)

  level1Features: IClassFeature[]; // Features gained at Level 1
  featureChoicesLvl1?: IClassFeatureChoice[]; // Choices available for features at Level 1
  // ... other level-specific data to be added later
}

// Interface for Skill Data
export interface ISkillData {
  id: string;
  name: string;
  attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence'; // Associated attribute
  description: string;
}

// Interface for Trade Data
export interface ITradeData {
  id: string;
  name: string;
  attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence'; // Associated attribute
  description: string;
  tools?: string; // Required tools for the trade
}

// Interface for Language Data
export interface ILanguageData {
  id: string;
  name: string;
  type: 'standard' | 'exotic'; // Type of language
}
</file>

<file path="src/lib/stores/characterInProgressStore.ts">
// src/lib/stores/characterInProgressStore.ts

import { writable, derived } from 'svelte/store';
import type { Writable } from 'svelte/store';
import type { CharacterInProgress } from '@prisma/client'; // Assuming Prisma client is generated

// Define the shape of the data stored in the characterInProgressStore
// This should mirror the CharacterInProgress Prisma model, plus any UI state
interface CharacterInProgressStoreData extends CharacterInProgress {
  // Add any UI-specific state here if needed, e.g., current step in wizard
  currentStep: number;
  // Add temporary state for trait selection overflow
  overflowTraitId: string | null;
  overflowAttributeName: string | null;
}

// Initial state for the store, matching Prisma defaults and adding UI state
const initialCharacterInProgressState: CharacterInProgressStoreData = {
  id: null, // Will be set when a new character is started/loaded
  attribute_might: -2,
  attribute_agility: -2,
  attribute_charisma: -2,
  attribute_intelligence: -2,
  pointsSpent: 0,

  ancestry1Id: null,
  ancestry2Id: null,
  selectedTraitIds: '', // JSON string of selected trait IDs
  ancestryPointsSpent: 0,

  classId: null,
  selectedFeatureChoices: '', // JSON string of selected feature choice IDs/values

  // Skills, Equipment, Details fields will be added/updated later
  finalName: null,
  finalPlayerName: null,

  finalCharacterSheet: null, // This will be populated when creation is complete

  createdAt: new Date(), // Placeholder, will be set by DB
  updatedAt: new Date(), // Placeholder, will be set by DB

  // UI State
  currentStep: 1, // Start at Stage A (Attributes)
  overflowTraitId: null,
  overflowAttributeName: null,
};

// Create the writable store
export const characterInProgressStore: Writable<CharacterInProgressStoreData> = writable(initialCharacterInProgressState);

// Helper function to get an attribute's modifier
// In DC20, the attribute score itself is the modifier.
// Handles null or undefined scores by returning 0.
export function getModifier(attributeScore: number | null | undefined): number {
  return attributeScore ?? 0;
}

// Constant for Level 1 Combat Mastery (DC20 p.22)
export const L1_COMBAT_MASTERY = 1;

// --- Derived Stores ---

// Derived store for the Prime Modifier Value and Attribute
export const primeModifier = derived(
  characterInProgressStore,
  ($store) => {
    const attributes = [
      { name: 'Might', value: $store.attribute_might },
      { name: 'Agility', value: $store.attribute_agility },
      { name: 'Charisma', value: $store.attribute_charisma },
      { name: 'Intelligence', value: $store.attribute_intelligence },
    ];

    // Find the highest attribute score
    let highestAttribute = attributes[0];
    for (let i = 1; i < attributes.length; i++) {
      if (attributes[i].value > highestAttribute.value) {
        highestAttribute = attributes[i];
      }
    }

    // Handle ties: If there's a tie, the player chooses.
    // For now, we'll just pick the first one in case of a tie.
    // A more complex implementation might require user input on tie-breaking.
    const primeModifierValue = highestAttribute.value;
    const primeModifierAttribute = highestAttribute.name;

    return { value: primeModifierValue, attribute: primeModifierAttribute };
  }
);

// Derived store for Save Masteries (DC20 p.22)
export const saveMasteries = derived(
  [characterInProgressStore, primeModifier],
  ([$store, $primeModifier]) => {
    const primeModValue = $primeModifier.value;
    const primeModAttribute = $primeModifier.attribute;

    // Save Mastery = Combat Mastery + Attribute Modifier
    // If the attribute is the Prime Modifier, use the Prime Modifier value.
    // Otherwise, use the attribute's own modifier (which is the score itself).
    return {
      might: L1_COMBAT_MASTERY + (primeModAttribute === 'Might' ? primeModValue : getModifier($store.attribute_might)),
      agility: L1_COMBAT_MASTERY + (primeModAttribute === 'Agility' ? primeModValue : getModifier($store.attribute_agility)),
      charisma: L1_COMBAT_MASTERY + (primeModAttribute === 'Charisma' ? primeModValue : getModifier($store.attribute_charisma)),
      intelligence: L1_COMBAT_MASTERY + (primeModAttribute === 'Intelligence' ? primeModValue : getModifier($store.attribute_intelligence)),
    };
  }
);

// Derived store for Grit Points (Base + Charisma Modifier)
export const gritPoints = derived(
  characterInProgressStore,
  ($store) => {
    // Assuming base Grit Points are defined in class data, but for now use a placeholder
    const baseGrit = 2; // Placeholder, should come from class data
    return baseGrit + getModifier($store.attribute_charisma);
  }
);

// Derived store for Jump Distance (Agility Modifier, min 1)
export const jumpDistance = derived(
  characterInProgressStore,
  ($store) => {
    const agilityModifier = getModifier($store.attribute_agility);
    return agilityModifier < 1 ? 1 : agilityModifier;
  }
);

// Derived store for Provisional Skill Points (5 + Intelligence Modifier + Class Bonus)
export const provisionalSkillPoints = derived(
  characterInProgressStore,
  ($store) => {
    const intelligenceModifier = getModifier($store.attribute_intelligence);
    // Assuming class data is available to get skillPointGrantLvl1
    // For now, use a placeholder of 0 if classId is not set
    const classSkillBonus = 0; // Placeholder, should come from class data based on $store.classId
    return 5 + intelligenceModifier + classSkillBonus;
  }
);

// Derived store for Ancestry Points Remaining (Base 4 + Negative Traits - Spent)
export const ancestryPointsRemaining = derived(
  characterInProgressStore,
  ($store) => {
    const basePoints = 4; // DC20 p.16
    // Need to access traitsData to calculate points from negative traits
    // For now, this calculation is incomplete without access to traitsData
    const pointsFromNegativeTraits = 0; // Placeholder
    return basePoints + pointsFromNegativeTraits - $store.ancestryPointsSpent;
  }
);

// TODO: Add more derived stores for other calculated stats (HP, SP, MP, Defenses, etc.)
</file>

<file path="projectPlan/mvp.md">
# Project: DC20 Level 1 Character Creator MVP

## I. Core Technologies
*   **Framework:** SvelteKit (Full-stack JavaScript/TypeScript)
*   **UI Primitives:** Melt UI (Primary)
*   **Styling:** TailwindCSS
*   **Fallback/Alternative UI:** `shadcn-svelte` (using Bits UI) / Bits UI directly, if needed for specific components or faster styling.
*   **ORM & Migrations:** Prisma
*   **Database:** Render Free PostgreSQL

## II. UI Design & Aesthetics
*   **Theme:** Dark Mode (Primary)
*   **Style:** Modern and Clean
*   **Primary Color Palette (Chosen):**
    *   `#FFBE0B` (Yellow - Accent, Highlights, Positive Feedback)
    *   `#FB5607` (Orange - Secondary Accent, Warnings)
    *   `#FF006E` (Magenta/Rose - Energetic Accent, Errors, Negative Feedback)
    *   `#8338EC` (Purple - Primary Action, Links, Key UI Elements)
    *   `#3A86FF` (Blue - Informational, Secondary Actions)
    *   *Dark Backgrounds:* Various shades of very dark gray/near-black (e.g., `#111827`, `#1F2937`, `#0D1117` from Tailwind's gray scale or custom)
    *   *Text Colors:* Light grays/off-whites for readability on dark backgrounds (e.g., `#E5E7EB`, `#D1D5DB`).
*   **Primary Font:** Inter (Variable font, allowing for different weights from a single family). Configured in Tailwind.
*   **Alternative Color Palettes (For Future Reference):**
    *   `https://coolors.co/palette/f94144-f3722c-f8961e-f9844a-f9c74f-90be6d-43aa8b-4d908e-577590-277da1`
    *   `https://coolors.co/palette/007f5f-2b9348-55a630-80b918-aacc00-bfd200-d4d700-dddf00-eeef20-ffff3f`
    *   `https://coolors.co/03071e-370617-6a040f-9d0208-d00000-dc2f02-e85d04-f48c06-faa307-ffba08`
    *   `https://coolors.co/7400b8-6930c3-5e60ce-5390d9-4ea8de-48bfe3-56cfe1-64dfdf-72efdd-80ffdb`
    *   `https://coolors.co/f72585-b5179e-7209b7-560bad-480ca8-3a0ca3-3f37c9-4361ee-4895ef-4cc9f0`

## III. MVP Feature Scope
1.  **Character Creation Wizard (Level 1 Only):**
    *   Guided, 6-stage UI implementing the initial stages (A-Attributes, B-Ancestry, C-Class) of the re-ordered flow (A-Attributes, B-Ancestry, C-Class, D-Background, E-Review, F-Equipment). These stages incorporate decision points from DC20's original 10 steps for Level 1.
    *   Visual-only breadcrumbs indicating progress through the re-ordered stages.
    *   Input fields, selections, point allocation with real-time validation for Level 1 constraints.
    *   Dynamic *provisional* updates of relevant stats on the frontend as choices are made.
    *   Data for the current creation process saved to the database (`CharacterInProgress` table) after each wizard step is completed by the user.
2.  **Character Page Output:**
    *   Upon completion of the wizard, all character data is finalized, calculated on the backend, and stored in a `CharacterSheetData` table.
    *   A dedicated page displays this finalized Level 1 character sheet data in a structured, readable HTML format, styled according to the dark mode, modern & clean aesthetic.
3.  **Data Persistence:**
    *   `CharacterInProgress` table: Stores intermediate data as the user moves through the wizard.
    *   `CharacterSheetData` table: Stores the final, calculated data for a completed Level 1 character.

## IV. Data Modeling (Prisma Schema)
*   **`CharacterInProgress` Table:**
    *   `id`: String `@id @default(uuid())`
    *   `characterName`: String?
    *   `currentWizardStage`: String `@default("A")` (e.g., "A", "B", "C" for re-ordered stages)
    *   `createdAt`: DateTime `@default(now())`
    *   `updatedAt`: DateTime `@updatedAt`
    *   **Stage A Data:**
        *   `attribute_might`: Int `@default(-2)`
        *   `attribute_agility`: Int `@default(-2)`
        *   `attribute_charisma`: Int `@default(-2)`
        *   `attribute_intelligence`: Int `@default(-2)`
        *   `primeModifierAttributeChoice`: String? // Stores "Might", "Agility", etc. if there's a tie.
    *   **Stage B Data:**
        *   `selectedAncestry1Id`: String?
        *   `selectedAncestry2Id`: String?
        *   `selectedAncestryTraitsJson`: String? // JSON string: `[{ "traitId": "human_resolve", "sourceAncestryId": "human" }, ...]`
    *   **Stage C Data:**
        *   `selectedClassId`: String?
        *   `classFeatureChoicesLvl1Json`: String? // JSON string: `{ "sorcerousOrigin": "intuitive_magic" }`
    *   *(Fields for Stage D, E, F to be added as those stages are detailed)*
*   **`CharacterSheetData` Table:**
    *   `id`: String `@id @default(uuid())`
    *   `characterInProgressId`: String @unique // Links to the completed CharacterInProgress
    *   `characterInProgress`: CharacterInProgress @relation(fields: [characterInProgressId], references: [id])
    *   **Final Output Fields (Level 1 Character Sheet):**
        *   `finalName: String`
        *   `finalPlayerName: String?`
        *   `finalLevel: Int @default(1)`
        *   `finalMight: Int`
        *   `finalAgility: Int`
        *   `finalCharisma: Int`
        *   `finalIntelligence: Int`
        *   `finalPrimeModifierValue: Int`
        *   `finalPrimeModifierAttribute: String`
        *   `finalCombatMastery: Int @default(1)`
        *   `finalSaveMasteryMight: Int`
        *   `finalSaveMasteryAgility: Int`
        *   `finalSaveMasteryCharisma: Int`
        *   `finalSaveMasteryIntelligence: Int`
        *   `finalHPMax: Int`
        *   `finalSPMax: Int`
        *   `finalMPMax: Int`
        *   `finalPD: Int`
        *   `finalAD: Int`
        *   `finalPDR: String?`
        *   `finalEDR: String?`
        *   `finalMDR: String?`
        *   `finalSaveDC: Int`
        *   `finalDeathThreshold: Int`
        *   `finalMoveSpeed: Int`
        *   `finalJumpDistance: Int`
        *   `finalRestPoints: Int`
        *   `finalGritPoints: Int`
        *   `finalInitiativeBonus: Int`
        *   `skillsJson: String` // `[{ id: 'athletics', name: 'Athletics', masteryLevel: 'Novice', bonus: 2, attribute: 'Might' }, ...]`
        *   `tradesJson: String` // `[{ id: 'alchemy', name: 'Alchemy', masteryLevel: 'Novice', bonus: 2, attribute: 'Intelligence' }, ...]`
        *   `languagesJson: String` // `[{ id: 'common', name: 'Common', fluency: 'Fluent' }, ...]`
        *   `ancestry1Name: String?`
        *   `ancestry2Name: String?`
        *   `selectedTraitsJson: String` // `[{ id: 'human_resolve', name: 'Human Resolve', cost: 1, description: '...', sourceAncestryName: 'Human' }, ...]`
        *   `className: String`
        *   `classFeaturesLvl1Json: String` // `[{ name: 'Rage', description: '...' }, { name: 'Sorcerous Origin', choice: 'Intuitive Magic', description: '...'}]`
        *   `equipmentJson: String` // `[{ name: 'Longsword', type: 'Weapon', ... }, ...]`
    *   `createdAt`: DateTime `@default(now())`
    *   `updatedAt`: DateTime `@updatedAt`
*   **Static Rule Data:**
    *   Initially embedded as TypeScript objects/arrays within the SvelteKit application (e.g., in `src/lib/rulesdata/`). TypeScript interfaces (e.g., `IAncestry`, `ITrait`, `IClass`) will define the structure. Effect encoding standardized (e.g., `effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'Might', value: 1 }]`).

## V. Key Backend Logic (SvelteKit Form Actions / API Routes)
*   One SvelteKit Form Action per wizard stage (e.g., `/wizard/stageA`, `/wizard/stageB`, etc.) to save/update `CharacterInProgress` data.
*   Endpoint/Form Action to finalize character creation:
    *   Takes `CharacterInProgress.id`.
    *   Performs all final calculations based on stored choices and embedded rule data.
    *   Validates all rules and constraints.
    *   Creates a new `CharacterSheetData` record.
*   Endpoint to fetch `CharacterSheetData` for display.
*   Backend re-validates all inputs for each stage. Final authoritative calculations for `CharacterSheetData` happen on the backend.

## VI. Key Frontend Logic & UI Implementation (SvelteKit with Melt UI & TailwindCSS)
*   **Wizard Structure:** A main Svelte component managing the current stage, with child components for each re-ordered stage (A, B, C initially).
*   **State Management:** A single, comprehensive writable Svelte store (`characterInProgressStore`) mirroring `CharacterInProgress` model plus transient UI state. Derived stores for calculated UI values.
*   **UI Components (Built using Melt UI primitives & styled with TailwindCSS):**
    *   Core Melt Primitives: `Button`, `Label`, `Input`, `Select`, `RadioGroup`, `Checkbox`, `Dialog`, `Tooltip`, `Progress`.
    *   Custom Composite Components: `WizardLayout.svelte`, `Breadcrumbs.svelte` (visual-only for MVP), `StageContainer.svelte`, `PointAllocator.svelte`, `StatDisplay.svelte` (for snapshot panel), `SelectionCard.svelte`.
*   **Styling:** TailwindCSS. Configuration includes chosen color palette and Inter font family. `darkMode: 'class'` with default to dark.
*   **Accessibility:** Leverage Melt UI's built-in features.
*   **Validation:** Real-time frontend validation with inline error messages next to problematic fields. Backend errors handled via SvelteKit Form Action responses.
*   **Character Sheet Display:** A dedicated Svelte route/page rendering `CharacterSheetData`.

## VII. Specific Planning Decisions (from Checklist)
*   **Complex Selections (Traits, Features):** Stored as JSON strings in `CharacterInProgress` for MVP.
*   **Static Rule Data Storage:** Hardcoded TypeScript objects/arrays in `src/lib/rulesdata/` for MVP.
*   **Svelte Store:** Single `characterInProgressStore` (writable), with extensive use of derived stores.
*   **Backend API:** One SvelteKit Form Action per wizard stage.
*   **Calculations:** Frontend for provisional UI display; backend for authoritative validation and final `CharacterSheetData` calculation.
*   **Error Handling:** Inline frontend messages; SvelteKit Form Action error patterns for backend errors.
*   **Resume Creation (MVP):** Use browser `localStorage` to store the `id` of the last edited `CharacterInProgress` record for basic resume functionality.
*   **Reusable Components:** Focus on `SelectionCard.svelte`, `PointAllocator.svelte`, `CharacterSnapshotPanel.svelte`.
*   **Tailwind Dark Mode:** `darkMode: 'class'`, default to dark.

## VIII. Post-MVP Considerations (Out of Scope for Initial Build)
*   Stages D (Background), E (Review), F (Equipment) of the wizard.
*   Character Level Up Wizard
*   Create Custom Equipment
*   Name Generator
*   Character Image & Token Generator (beyond simple upload)
*   PDF Output / Advanced Character Sheet Styling
*   User Accounts & Authentication
*   Sharing Characters
*   Moving Static Rule Data to Database
*   Interactive breadcrumb navigation (allowing edits to previous steps with full recalculation).
*   Light Mode Theme & UI Theme Toggle.
*   Different font classes for UI/Title.

## Appendix: Static Rule Data Definition
Detailed TypeScript interfaces for static rule data will be defined in `src/lib/rulesdata/types.ts`. Key interfaces include:

*   `IAttributeData { id: 'might' | 'agility' | 'charisma' | 'intelligence'; name: string; description: string; derivedStats?: Array<{ statName: string; formula: string; }>; }`
*   `ITraitEffect { type: string; target?: string; value?: any; condition?: string; userChoiceRequired?: { prompt: string; options?: string[] }; descriptionOverride?: string; }`
*   `ITrait { id: string; name: string; description: string; cost: number; isMinor?: boolean; isNegative?: boolean; effects?: ITraitEffect[]; prerequisites?: any[]; }`
*   `IAncestry { id: string; name: string; description: string; defaultTraitIds?: string[]; expandedTraitIds: string[]; }`
*   `IClassFeatureChoiceOption { value: string; label: string; description?: string; }`
*   `IClassFeatureChoice { id: string; prompt: string; type: 'select_one' | 'select_multiple'; maxSelections?: number; options: IClassFeatureChoiceOption[]; effectsOnChoice?: { [choiceValue: string]: ITraitEffect[] }; }`
*   `IClassFeature { id: string; name: string; description: string; level: number; effects?: ITraitEffect[]; }`
*   `IClassDefinition { id: string; name: string; ... baseHpContribution: number; startingSP: number; startingMP: number; skillPointGrantLvl1?: number; ... level1Features: IClassFeature[]; featureChoicesLvl1?: IClassFeatureChoice[]; ... }`
*   `ISkillData { id: string; name: string; attributeAssociation: string; description: string; }`
*   `ITradeData { id: string; name: string; attributeAssociation: string; description: string; tools?: string; }`
*   `ILanguageData { id: string; name: string; type: string; }`
</file>

<file path="projectPlan/stage1.md">
# AI Generation Guide: Character Creator - Stage A (Attributes, Prime Modifier, Foundational Stats - Point Buy)

## I. Overall Stage Objective
Create a Svelte component (e.g., `StageA_Attributes.svelte`) that allows the user to:
1.  Allocate 12 attribute points using the Point Buy method (starting from -2 in each of Might, Agility, Charisma, Intelligence) for Level 1 characters (max +3 per attribute).
2.  View the automatically calculated Prime Modifier (with a user choice for ties).
3.  View the automatically calculated Save Mastery bonus for each attribute.
4.  View the automatically calculated Grit Points, Jump Distance, and provisional Skill Point total.
5.  View provisional formulas/known components for Health, SP, MP, PD, AD.
6.  Persist these choices to a Svelte store and, upon proceeding, save to the `CharacterInProgress` table via a backend API call.

## II. Svelte Component: `StageA_Attributes.svelte`

### A. Props:
*   `characterInProgressStore`: Writable Svelte store holding the current character creation data.

### B. Internal State (Reactive Svelte Variables):
*   `pointBuyBudget`: Number (constant: 12)
*   `attributes`: Object (e.g., `{ Might: -2, Agility: -2, Charisma: -2, Intelligence: -2 }`) - *User modifies these values.*
*   `pointsSpent`: Reactive/Derived Number (`$: pointsSpent = calculatePointsSpent(attributes)`)
*   `pointsRemaining`: Reactive/Derived Number (`$: pointsRemaining = pointBuyBudget - pointsSpent`)
*   `primeModifierAttribute`: String (Might, Agility, Charisma, or Intelligence - user choice if tie)
*   `primeModifierValue`: Reactive/Derived Number (`$: primeModifierValue = attributes[primeModifierAttribute]`)
*   `saveMasteries`: Reactive/Derived Object (`$: saveMasteries = calculateSaveMasteries(attributes, L1_COMBAT_MASTERY)`)
*   `gritPoints`: Reactive/Derived Number (`$: gritPoints = 2 + getModifier(attributes.Charisma)`)
*   `jumpDistance`: Reactive/Derived Number (`$: jumpDistance = attributes.Agility < 1 ? 1 : attributes.Agility`)
*   `provisionalSkillPoints`: Reactive/Derived Number (`$: provisionalSkillPoints = 5 + getModifier(attributes.Intelligence)`)
*   `L1_COMBAT_MASTERY`: Number (constant: 1) - *Sourced from global static rule data (DC20 p.22).*

### C. UI Structure & Components (Melt UI + TailwindCSS):

**1. Main Container (`div`):**
    *   Tailwind: `p-6 md:p-8 bg-dark-bg-secondary rounded-lg shadow-xl text-light-text-primary`

**2. Stage Title (`h2`):**
    *   Text: "Step 1: Core Attributes & Foundational Stats"
    *   Tailwind: `text-2xl font-semibold mb-6 text-yellow-accent` (using Inter font)

**3. Point Buy Allocation Section (`div` section):**
    *   Title (`h3`): "Allocate Attribute Points (Point Buy)" (Tailwind: `text-lg font-medium mb-2`)
    *   Budget Display (`p`): "Budget: {pointsRemaining} / 12 Points Remaining" (Tailwind: `mb-4 text-light-text-secondary`)
        *   Dynamically change text color to `magenta-error` if `pointsRemaining < 0`.
    *   Layout: CSS Grid (`grid grid-cols-1 md:grid-cols-2 gap-6 mb-6`)
    *   **For each of the 4 attributes (Might, Agility, Charisma, Intelligence):**
        *   Attribute Card (`div`):
            *   Tailwind: `p-4 bg-dark-bg-primary rounded-md shadow-sm relative flex flex-col justify-between`
            *   Dynamic Tailwind class if this attribute is the `primeModifierAttribute`: `border-2 border-yellow-accent`
        *   **Top Section:**
            *   Attribute Name & Save Mastery (`div`):
                *   Tailwind: `flex justify-between items-center mb-1`
                *   Name (Melt UI `Label` for the input): e.g., "Might" (Tailwind: `text-xl font-medium text-light-text-primary`)
                *   Save Mastery (`span`): e.g., "Save: +{saveMasteries.Might}" (Tailwind: `text-blue-info font-medium`)
            *   Attribute Description (`p`):
                *   Text: "Your Strength of Body." (Might)
                *   Text: "Your Balance, Nimbleness, and Dexterity." (Agility)
                *   Text: "Your Charm, Presence, Persuasiveness, and Force of Will." (Charisma)
                *   Text: "Your Reasoning, Understanding, and Wisdom." (Intelligence)
                *   Tailwind: `text-sm text-light-text-secondary mb-2`
        *   **Bottom Section - Input & Derived Stats:**
            *   Point Buy Input Control (`div`):
                *   Tailwind: `flex items-center gap-2 mb-2`
                *   Melt UI `Button` (for "-"): Tailwind: `p-2 h-8 w-8 flex items-center justify-center bg-magenta-error/70 hover:bg-magenta-error rounded-md text-lg`
                *   Melt UI `Input` (type="number", readonly): Displays current `attributes.Might`. Tailwind: `w-12 text-center text-xl font-semibold bg-dark-bg-secondary rounded-md p-1 h-8`
                *   Melt UI `Button` (for "+"): Tailwind: `p-2 h-8 w-8 flex items-center justify-center bg-purple-primary/70 hover:bg-purple-primary rounded-md text-lg`
            *   **Integrated Derived Stats Display (Conditional on attribute):**
                *   If Charisma: `span` "Grit: {gritPoints}" (Tailwind: `text-xs text-light-text-secondary`)
                *   If Agility: `span` "Jump: {jumpDistance}" (Tailwind: `text-xs text-light-text-secondary`)
                *   If Intelligence: `span` "Skill Pts (Base): {provisionalSkillPoints}" (Tailwind: `text-xs text-light-text-secondary`)
    *   **Prime Modifier Tie-Breaker (Conditional UI):**
        *   If a tie for highest attribute occurs:
            *   Message (`p`): "Multiple attributes are tied for highest. Please select your Prime Modifier:" (Tailwind: `my-4 text-yellow-accent`)
            *   Melt UI `RadioGroup` (`<RadioGroup.Root bind:value={$primeModifierAttribute}>`):
                *   Tailwind: `flex gap-4`
                *   `RadioGroup.Item` for each tied attribute, styled.

**4. Key Calculated Stats Display (`div` section):**
    *   Tailwind: `mt-6 grid grid-cols-1 md:grid-cols-2 gap-4`
    *   Prime Modifier Card (`div`):
        *   Tailwind: `p-4 bg-purple-primary/20 rounded-lg text-center`
        *   Label (`span`): "Prime Modifier: " (Tailwind: `text-lg text-light-text-primary`)
        *   Value (`span`): "{primeModifierValue}" (Tailwind: `text-2xl font-bold text-yellow-accent`)
    *   Provisional Skill Points Card (`div`):
        *   Tailwind: `p-4 bg-dark-bg-primary rounded-lg text-center`
        *   Label (`span`): "Base Skill Points (5 + Int Mod): " (Tailwind: `text-md text-light-text-primary`)
        *   Value (`span`): "{provisionalSkillPoints}" (Tailwind: `text-xl font-semibold text-blue-info`)

**5. Provisional Formulas Display (`div` section):**
    *   Title (`h3`): "Provisional Base Stats (Finalized after Class & Equipment)" (Tailwind: `text-lg font-medium mt-6 mb-3`)
    *   Layout: Tailwind: `grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2 text-sm text-light-text-secondary`
    *   `p`: "Health Points = Class HP + Might ({attributes.Might}) + Ancestry HP"
    *   `p`: "Stamina Points = Class SP"
    *   `p`: "Mana Points = Class MP"
    *   `p`: "Precision Defense (PD) = 8 + CM(+1) + Agility ({attributes.Agility}) + Intelligence ({attributes.Intelligence}) + Equip Bonuses"
    *   `p`: "Area Defense (AD) = 8 + CM(+1) + Might ({attributes.Might}) + Charisma ({attributes.Charisma}) + Equip Bonuses"

### D. Functions & Logic:
*   `getModifier(attributeScore)`: Helper function to get an attribute's modifier. In DC20, the attribute score itself (e.g., +2, -1, 0) is directly used as the modifier. This function should `return attributeScore;`. It handles `null` or `undefined` scores by returning `0`.
*   `calculatePointsSpent(attributes)`:
    *   Calculates total points spent. Each attribute starts at -2. Each +1 increase costs 1 point. Total budget is 12 points. Formula: `sum(current_attr_value - (-2))` should equal 12 when done.
*   `calculateSaveMasteries(attributes, combatMastery)`:
    *   Calculates Save Mastery for each attribute. Formula: `attributeScore + combatMastery`. Combat Mastery (CM) at Level 1 is +1 (DC20, p.22).
*   Event handlers for attribute +/- buttons:
    *   Increment/decrement the specific attribute.
    *   Ensure attribute value stays within -2 and +3 (Level 1 limit). The Level 1 attribute cap is +3.
    *   Update `characterInProgressStore`.
*   Logic to determine `primeModifierAttribute`:
    *   Find the highest attribute(s).
    *   If one is highest, set it.
    *   If multiple are tied, enable the tie-breaker UI and use the user's selection.
*   Validation logic:
    *   `pointsRemaining` cannot be negative when user tries to advance (or disable increment buttons if budget met).
    *   Ensure no attribute exceeds the Level 1 cap of +3.
*   Function to persist current state to `characterInProgressStore` and call backend API on "Next Step".

### E. Styling Notes (TailwindCSS):
*   Use Inter font with appropriate weights.
*   Adhere to the chosen dark mode color palette.
*   Ensure clear visual hierarchy and readability.
*   Tooltips (Melt UI `Tooltip`) next to calculated values (Prime Modifier, Save Masteries, Grit, Jump, Skill Pts) explaining their calculation formula briefly (e.g., "Prime: Highest Attribute", "Save: Attribute + Combat Mastery (+1)").

## VI. Backend API Endpoint (`/api/character/progress/stageA` - SvelteKit Form Action or API Route)
*   Accepts: `attributes` object from the frontend.
*   Validates:
    *   Each attribute is between -2 and +3.
    *   Total points spent from a -2 base for all attributes equals 12.
*   Action: Saves the validated `attributes` to the `CharacterInProgress` table using Prisma.
*   Returns: Success/error response.

---
</file>

<file path="projectPlan/stage2.md">
# AI Generation Guide: Character Creator - Stage B (Ancestry Choices with Overflow Helper Panel)

## I. Overall Stage Objective
Create a Svelte component (e.g., `StageB_Ancestry.svelte`) that allows the user to:
1.  Select 1 or 2 Ancestries.
2.  Allocate 5 Ancestry Points for Traits from the chosen Ancestry/Ancestries, respecting rules (Minor Trait limit, Negative Trait point gain).
3.  If an Ancestry Trait would cause an attribute (set in Stage A) to exceed its Level 1 cap (+3), present a Helper Panel to allow the user to reduce other attributes to make room.
4.  View chosen traits and the impact on Ancestry Points.
5.  View the (read-only but dynamically updated) stats from Stage A, reflecting any changes made due to trait selections or reallocations via the Helper Panel.
6.  Persist these choices to a Svelte store and, upon proceeding, save to the `CharacterInProgress` table.

## II. Svelte Component: `StageB_Ancestry.svelte`

### A. Props:
*   `characterInProgressStore`: Writable Svelte store (holds `attributesFromStageA`, `selectedAncestries`, `selectedTraits`, `ancestryPointsAvailable`, etc.). Attribute values (e.g., `$characterInProgressStore.attribute_might`) set in Stage A are accessed from this store for display and overflow calculations.

### B. Internal State (Reactive Svelte Variables):
*   `selectedAncestry1_ID`: String | null
*   `selectedAncestry2_ID`: String | null
*   `availableTraitsForSelection`: Reactive/Derived Array (based on selected ancestries)
*   `currentSelectedTraits`: Array of Trait Objects (e.g., `[{ id: 'human_resolve', cost: 1, name: 'Human Resolve', ...}, ...]`)
*   `ancestryPointsBudget`: Number (constant: 5)
*   `pointsFromNegativeTraits`: Reactive/Derived Number
*   `totalAncestryPointsAvailable`: Reactive/Derived Number (`$: ancestryPointsBudget + pointsFromNegativeTraits`)
*   `ancestryPointsSpent`: Reactive/Derived Number
*   `ancestryPointsRemaining`: Reactive/Derived Number (`$: totalAncestryPointsAvailable - ancestryPointsSpent`)
*   `showOverflowHelperPanel`: Boolean (default: false)
*   `overflowTrait`: Object | null (the trait causing the overflow)
*   `overflowAttributeName`: String | null
*   `overflowAmount`: Number (how many points attribute would go over cap)
*   `tempAttributesForReallocation`: Object (copy of current `attributesFromStageA` for use in panel)
*   `pointsFreedInPanel`: Number (tracks how many points user has reduced in panel)

### C. UI Structure & Components (Melt UI + TailwindCSS):

**1. Main Container & Stage Title:** (Similar to Stage A)
    *   Title (`h2`): "Step 2: Ancestry Choices"

**2. Ancestry Selection Section (`div`):**
    *   Title (`h3`): "Choose Your Ancestry (Up to 2)"
    *   Two Melt UI `Select` components (or custom `SelectionCard`s):
        *   For "Ancestry 1" (bind to `selectedAncestry1_ID`)
        *   For "Ancestry 2" (bind to `selectedAncestry2_ID`, with a "None" option).
        *   Populated from static rule data. Styled with Tailwind.

**3. Ancestry Points & Trait Allocation Section (`div`):**
    *   Budget Display (`p`): "Ancestry Points: {ancestryPointsRemaining} / {totalAncestryPointsAvailable} Remaining"
    *   **Conditional Trait Listing (for Ancestry 1 and Ancestry 2 if selected):**
        *   For each selected ancestry:
            *   Subtitle (`h4`): "[Ancestry Name] Traits"
            *   List (`ul`) of its available traits:
                *   Each trait item (`li` - Tailwind: `flex items-center justify-between p-2 my-1 rounded dark:hover:bg-dark-bg-primary`):
                    *   Melt UI `Checkbox` (or `Toggle`) for selection (bind checked state to logic that updates `currentSelectedTraits` and points).
                    *   Label: Trait Name (Cost: X) - (Tailwind: `font-medium`). Dynamic class if selected (`text-yellow-accent`).
                    *   Melt UI `Tooltip` (on hover/focus on trait name): Shows full trait description.
                    *   *If selecting this trait would cause an overflow AND the Helper Panel isn't already open for it, clicking it should trigger `openOverflowHelperPanel(trait)` instead of direct selection.*
    *   *Trait listings (name, cost, description, effects, Minor/Negative flags) are populated from static rule data, using `IAncestry` and `ITrait` TypeScript interfaces.*

**2. Ancestry Selection Section (`div`):**
    *   Title (`h3`): "Choose Your Ancestry (Up to 2)"
    *   Two Melt UI `Select` components (or custom `SelectionCard`s):
        *   For "Ancestry 1" (bind to `selectedAncestry1_ID`)
        *   For "Ancestry 2" (bind to `selectedAncestry2_ID`, with a "None" option).
        *   Populated from static rule data. Styled with Tailwind.

**3. Ancestry Points & Trait Allocation Section (`div`):**
    *   Budget Display (`p`): "Ancestry Points: {ancestryPointsRemaining} / {totalAncestryPointsAvailable} Remaining"
    *   **Conditional Trait Listing (for Ancestry 1 and Ancestry 2 if selected):**
        *   For each selected ancestry:
            *   Subtitle (`h4`): "[Ancestry Name] Traits"
            *   List (`ul`) of its available traits:
                *   Each trait item (`li` - Tailwind: `flex items-center justify-between p-2 my-1 rounded dark:hover:bg-dark-bg-primary`):
                    *   Melt UI `Checkbox` (or `Toggle`) for selection (bind checked state to logic that updates `currentSelectedTraits` and points).
                    *   Label: Trait Name (Cost: X) - (Tailwind: `font-medium`). Dynamic class if selected (`text-yellow-accent`).
                    *   Melt UI `Tooltip` (on hover/focus on trait name): Shows full trait description.
                    *   *If selecting this trait would cause an overflow AND the Helper Panel isn't already open for it, clicking it should trigger `openOverflowHelperPanel(trait)` instead of direct selection.*

**4. Chosen Traits Summary (`div`):**
    *   Title (`h3`): "Selected Traits"
    *   List (`ul`) of `currentSelectedTraits`, showing name, cost, and source ancestry.
    *   Tailwind: `mt-4 p-3 bg-dark-bg-primary rounded-md`

**5. Read-Only Display of Updated Stage A Stats (`div` - crucial for feedback):**
    *   Title (`h3`): "Current Core Stats (Reflecting Ancestry Choices)"
    *   Display Might, Agility, Cha, Int (from `$characterInProgressStore.attributesFromStageA`, which gets updated by Helper Panel).
    *   Display Prime Modifier, Save Masteries, Grit, Jump, Provisional Skill Points (all derived from updated attributes).
    *   Highlight the Prime Modifier attribute.

**6. Overflow Helper Panel (Melt UI `Dialog` - `Dialog.Root bind:open={$showOverflowHelperPanel}`):**
    *   Melt UI `Dialog.Trigger` (not explicitly needed if opened programmatically).
    *   Melt UI `Dialog.Portal` -> `Dialog.Overlay` (styled with Tailwind for dark semi-transparent bg) -> `Dialog.Content`
    *   **`Dialog.Content` Styling (Tailwind):** `bg-dark-bg-secondary p-6 rounded-lg shadow-xl w-full max-w-md text-light-text-primary`
    *   `Dialog.Title`: "Attribute Cap Reached for '{overflowTrait.name}'"
    *   `Dialog.Description` (`p`): "Selecting '{overflowTrait.name}' will increase '{overflowAttributeName}' by +{overflowTrait.attributeBonusValue}, exceeding the Level 1 cap of +3. You have {overflowAmount} point(s) to free up by reducing other attributes."
    *   **Attribute Reduction Section within Panel:**
        *   The panel allows reducing any attribute *except* the one `overflowAttributeName` (that the `overflowTrait` is trying to increase). Attributes cannot be reduced below -2.
        *   For each of the 4 attributes (displaying values from `tempAttributesForReallocation`):
            *   Label: Attribute Name: [Current Value in Panel]
            *   Melt UI `Button` ("-"):
                *   Disabled if attribute is `overflowAttributeName` or if its value in `tempAttributesForReallocation` is already -2.
                *   Action: Decrements the attribute in `tempAttributesForReallocation`, increments `pointsFreedInPanel`.
            *   *(No "+" button in this panel, only reduction is allowed)*
    *   Display (`p`): "Points Freed: {pointsFreedInPanel} / {overflowAmount}"
    *   **Panel Actions (`div` - Tailwind: `flex justify-end gap-3 mt-4`):**
        *   Melt UI `Button` ("Cancel Trait"):
            *   Action: `closeOverflowHelperPanel()`.
            *   Tailwind: `bg-gray-500 hover:bg-gray-600 ...`
        *   Melt UI `Button` ("Apply & Select Trait"):
            *   Disabled if `pointsFreedInPanel !== overflowAmount`.
            *   Action: `confirmAttributeReallocationAndSelectTrait()`.
            *   Tailwind: `bg-purple-primary hover:bg-purple-primary/80 ...`

### D. Functions & Logic:
*   `handleTraitSelection(trait)`:
    *   Checks for attribute overflow if trait modifies an attribute.
    *   If overflow: `openOverflowHelperPanel(trait)`. *Clicking a problematic trait triggers this instead of direct selection and point deduction.*
    *   Else: Toggles trait in `currentSelectedTraits`, updates point counts, checks Minor/Negative Trait limits.
*   `openOverflowHelperPanel(trait)`:
    *   Sets `overflowTrait`, `overflowAttributeName`, `overflowAmount`.
    *   Copies current `attributesFromStageA` to `tempAttributesForReallocation`.
    *   Resets `pointsFreedInPanel`.
    *   Sets `showOverflowHelperPanel = true`.
*   `closeOverflowHelperPanel()`:
    *   Sets `showOverflowHelperPanel = false`.
    *   Resets `overflowTrait`, `tempAttributesForReallocation`, `pointsFreedInPanel`.
*   `confirmAttributeReallocationAndSelectTrait()`:
    *   Updates the main `$characterInProgressStore.attributesFromStageA` with values from `tempAttributesForReallocation`.
    *   Adds `overflowTrait` to `currentSelectedTraits` and updates point counts.
    *   `closeOverflowHelperPanel()`.
*   Logic to enforce: Max 2 ancestries, 1 Minor Trait, max +2 points gain from Negative Traits, total Ancestry Points spent = 5 (after accounting for negative traits).
*   All choices and final attribute adjustments persisted to `characterInProgressStore` and then to backend.
*   **UI Feedback for Trait Rules:**
    *   When a Minor Trait is selected, disable selection of other Minor Traits and provide a tooltip/message.
    *   When selecting Negative Traits, `totalAncestryPointsAvailable` display updates. If the +2 point gain limit from Negative Traits is reached, disable further Negative Trait selection and message the user.
    *   Disable trait selection if `ancestryPointsRemaining` would be negative (unless it's a negative trait resolving this).

### E. Styling Notes (TailwindCSS):
*   Dark mode theme, Inter font, chosen color palette.
*   Clear visual distinction for selected ancestries and traits (`text-yellow-accent`, borders).
*   Helper Panel (Dialog) should feel like a focused, temporary interruption.

## VI. Backend API Endpoint (`/api/character/progress/stageB` - SvelteKit Form Action or API Route)
*   Accepts: `characterInProgressStore` data (including potentially modified `attributesFromStageA`, `selectedAncestries`, `selectedTraits`).
*   Validates:
    *   All attribute values are still within -2 and +3.
    *   Total points spent on attributes (from -2 base) still equals 12.
    *   Ancestry Point rules (total 5 points used, Minor Trait limit, Negative Trait limit).
*   Action: Saves/updates the relevant fields in the `CharacterInProgress` table using Prisma.
*   Returns: Success/error response.

---
</file>

<file path="projectPlan/tailwind.config.js">
// tailwind.config.js
module.exports = {
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        'yellow-accent': '#FFBE0B',
        'orange-secondary': '#FB5607',
        'magenta-error': '#FF006E',
        'purple-primary': '#8338EC',
        'blue-info': '#3A86FF',
        // Define your dark background shades
        'dark-bg-primary': '#111827', // Example: Tailwind gray-900
        'dark-bg-secondary': '#1F2937', // Example: Tailwind gray-800
        // Define your light text shades
        'light-text-primary': '#E5E7EB', // Example: Tailwind gray-200
        'light-text-secondary': '#D1D5DB', // Example: Tailwind gray-300
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'], // Make Inter the default sans-serif
      },
    },
  },
  // ... plugins
}
</file>

</files>
